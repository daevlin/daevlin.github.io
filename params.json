{"name":"daevlin.github.io","tagline":"Malware, meet Mr Stick and Mr Poke ","body":"# Zero2Auto custom sample analysis\r\n\r\n```\r\nShort summary report for the IR Team\r\n\r\nThe suspicous sample the IR team found on an infected machine has the following functionality:\r\nSpawns and injects itself into svhost.exe process to try and hide it's presence on the system\r\nActs like a downloader for additional malicous code\r\nUses legitimate webservices like Pastebin to get the next download stage to stay under the radar\r\nHides additional downloaded payloads in .PNG files, possibly to bypass FW/EDR/AV solutions\r\nThe final stage of the malicous code indicates the infected client has been \"Uh Oh Hacked\"\r\nI've attached the following Yara rule to this email,\r\nthat can help the IR team to find client(s) infected with this malware.\r\n\r\nrule Zero_2_Auto_CruLoader\r\n{\r\n\tmeta:\r\n\t    author=\"daevlin\"\r\n\t    description=\"Zero2Auto CruLoader\"\r\n\t    reference=\"https://courses.zero2auto.com/\"\r\n    strings:\r\n        $cruloader_pdb = \"Cruloader_Payload.pdb\" wide ascii\r\n        $cruloader_string = \"cruloader\" wide ascii\r\n\r\n\r\n    condition:\r\n        ($cruloader_pdb  or $cruloader_string)\r\n}\r\n\r\nHost based IOCs:\r\nAny svhost.exe processes with the wrong PPID which have been started without the -k switch\r\nThe existance of the folder %TEMP%\\\\cruloader\" with the file \"output.jpg\"\r\n\r\nNetwork based IOC:s\r\nhttps://pastebin.com/raw/mLem9DGk\r\nhttps://i.ibb.co/KsfqHym/PNG-02-Copy.png\r\nBrowser User-Agent: cruloader\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Detailed analysis of the custom sample from the chapter \"Practical Analysis and Test\r\n\r\nTools used. \"rabin2, rahex2, Resource Hacker, DiE, Cutter, x32dbg, Python, Inetsim, PE-Bear\"\r\n\r\nWe start by getting a hash of the file\r\n\r\n1) Sample SHA256: \r\na0ac02a1e6c908b90173e86c3e321f2bab082ed45236503a21eb7d984de10611  main_bin.exe\r\n\r\nFile seems to be compiled Sun Jun 21 16:12:38 2020. Seems to be no indication of time stomping.\r\n\r\nLooking at the hash on VT we can see that we get some hits\r\n\r\nScanned on : \r\n\t2020-06-21 14:15:51\r\n\r\nDetections:\r\n\t 24/72 Positives/Total\r\n\r\n\tResults for MD5    : a84e1256111e4e235250a8e3bb11f903\r\n\tResults for SHA1   : 1b76e5a645a0df61bb4569d54bd1183ab451c95e\r\n\tResults for SHA256 : a0ac02a1e6c908b90173e86c3e321f2bab082ed45236503a21eb7d984de10611\r\n\r\n\tPermanent Link : https://www.virustotal.com/gui/file/a0ac02a1e6c908b90173e86c3e321f2bab082ed45236503a21eb7d984de10611/detection/f-a0ac02a1e6c908b90173e86c3e321f2bab082ed45236503a21eb7d984de10611-1592748951\r\n\r\nWhich is a indicator that the sample might be malicous\r\n\r\nLooking at the imports with rabin2 -i main_bin.exe we can see that the sample import the following API calls:\r\n\r\n```\r\n\r\n[Imports]\r\nordinal=001 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_GetModuleFileNameA\r\nordinal=002 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_LoadLibraryA\r\nordinal=003 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_GetProcAddress\r\nordinal=004 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_WriteConsoleW\r\nordinal=005 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_UnhandledExceptionFilter\r\nordinal=006 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_SetUnhandledExceptionFilter\r\nordinal=007 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_GetCurrentProcess\r\nordinal=008 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_TerminateProcess\r\nordinal=009 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_IsProcessorFeaturePresent\r\nordinal=010 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_QueryPerformanceCounter\r\nordinal=011 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_GetCurrentProcessId\r\nordinal=012 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_GetCurrentThreadId\r\nordinal=013 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_GetSystemTimeAsFileTime\r\nordinal=014 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_InitializeSListHead\r\nordinal=015 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_IsDebuggerPresent\r\nordinal=016 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_GetStartupInfoW\r\nordinal=017 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_GetModuleHandleW\r\nordinal=018 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_RtlUnwind\r\nordinal=019 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_GetLastError\r\nordinal=020 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_SetLastError\r\nordinal=021 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_EnterCriticalSection\r\nordinal=022 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_LeaveCriticalSection\r\nordinal=023 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_DeleteCriticalSection\r\nordinal=024 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_InitializeCriticalSectionAndSpinCount\r\nordinal=025 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_TlsAlloc\r\nordinal=026 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_TlsGetValue\r\nordinal=027 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_TlsSetValue\r\nordinal=028 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_TlsFree\r\nordinal=029 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_FreeLibrary\r\nordinal=030 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_LoadLibraryExW\r\nordinal=031 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_RaiseException\r\nordinal=032 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_GetStdHandle\r\nordinal=033 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_WriteFile\r\nordinal=034 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_GetModuleFileNameW\r\nordinal=035 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_ExitProcess\r\nordinal=036 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_GetModuleHandleExW\r\nordinal=037 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_GetCommandLineA\r\nordinal=038 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_GetCommandLineW\r\nordinal=039 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_HeapAlloc\r\nordinal=040 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_HeapFree\r\nordinal=041 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_FindClose\r\nordinal=042 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_FindFirstFileExW\r\nordinal=043 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_FindNextFileW\r\nordinal=044 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_IsValidCodePage\r\nordinal=045 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_GetACP\r\nordinal=046 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_GetOEMCP\r\nordinal=047 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_GetCPInfo\r\nordinal=048 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_MultiByteToWideChar\r\nordinal=049 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_WideCharToMultiByte\r\nordinal=050 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_GetEnvironmentStringsW\r\nordinal=051 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_FreeEnvironmentStringsW\r\nordinal=052 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_SetEnvironmentVariableW\r\nordinal=053 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_SetStdHandle\r\nordinal=054 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_GetFileType\r\nordinal=055 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_GetStringTypeW\r\nordinal=056 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_CompareStringW\r\nordinal=057 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_LCMapStringW\r\nordinal=058 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_GetProcessHeap\r\nordinal=059 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_HeapSize\r\nordinal=060 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_HeapReAlloc\r\nordinal=061 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_FlushFileBuffers\r\nordinal=062 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_GetConsoleOutputCP\r\nordinal=063 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_GetConsoleMode\r\nordinal=064 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_SetFilePointerEx\r\nordinal=065 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_CreateFileW\r\nordinal=066 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_CloseHandle\r\nordinal=067 plt=0x00000000 bind=NONE type=FUNC name=KERNEL32.dll_DecodePointer\r\n\r\n```\r\n\r\nLooking at the sections of the binary with the following command \"rabin2 -S main_bin.exe\" \r\n\r\n```\r\n\r\n[Sections]\r\nidx=00 addr=0x00000400 off=0x00000400 sz=50688 vsz=50335 perm=-r-x name=.text\r\nidx=01 addr=0x0000ca00 off=0x0000ca00 sz=23040 vsz=23002 perm=-r-- name=.rdata\r\nidx=02 addr=0x00012400 off=0x00012400 sz=2560 vsz=5028 perm=-rw- name=.data\r\nidx=03 addr=0x00012e00 off=0x00012e00 sz=87552 vsz=87168 perm=-r-- name=.rsrc\r\nidx=04 addr=0x00028400 off=0x00028400 sz=4096 vsz=3768 perm=-r-- name=.reloc\r\n\r\n```\r\nWhat sticks out in this case is that the .rsrc section is quite big, but there are no calls to any API calls to access it, for example:\r\n\r\n```\r\nSizeofResource\r\nFindResourceA\r\nLockResource\r\nLoadResource \r\n\r\n```\r\n\r\nDiE does not indicate that the sample is packed with a known packer. But hiding API calls and the big .rsrc makes me have a theory that it is. I just have to prove it somehow.\r\n\r\ndiec main_bin.exe \r\nPE: compiler: Microsoft Visual C/C++(-)[-]\r\nPE: linker: Microsoft Linker(14.25)[EXE32,console]\r\n\r\nLooking at the file in \"Resource Hacker\". There is a RT_RCDATA resource with ID 101. The .rsrc is kind of big, 86 KB to be exact and seems to contains random bytes, which may indicate it's packed or encrypted/obfuscated.\r\n\r\n![Resource Hacker](/images/resource_hacker.png)\r\n\r\nThe .rsrc section also has quite a high entry, as shown by the diagram in DiE.\r\n\r\n![Detect It Easy](entropy_rsrc.png)\r\n\r\nLet's do some analysis of the suspicous binary in Cutter. What immediatly peaks my interest is what looks like a lookup table in the Strings pane in Cutter. \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890./=\"\r\n\r\nLooking a xrefs to the strings we come to this\r\n\r\n![Cutter Xrefs string decryption](calls_to_decrypt.png)\r\n\r\nThe decompiled the function looks like this in Cutter:\r\n\r\n```c\r\nvoid __fastcall fcn.00401300(char *param_1)\r\n{\r\n    char cVar1;\r\n    char cVar2;\r\n    int32_t iVar3;\r\n    int32_t *piVar4;\r\n    char *pcVar5;\r\n    int32_t iVar6;\r\n    int32_t iVar7;\r\n    int32_t var_4ch;\r\n    int32_t var_48h;\r\n    int32_t var_38h;\r\n    int32_t var_28h;\r\n    int32_t var_18h;\r\n    int32_t var_8h;\r\n    int32_t var_4h;\r\n    \r\n    iVar7 = 0;\r\n    pcVar5 = param_1;\r\n    do {\r\n        cVar1 = *pcVar5;\r\n        pcVar5 = pcVar5 + 1;\r\n    } while (cVar1 != '\\0');\r\n    if (pcVar5 != param_1 + 1 && -1 < (int32_t)(pcVar5 + -(int32_t)(param_1 + 1))) {\r\n        do {\r\n            cVar1 = param_1[iVar7];\r\n            var_48h = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890./=\"._0_4_;\r\n            cVar2 = fcn.004038f4(1);\r\n            iVar3 = fcn.00402190(&var_48h, (int32_t)cVar1);\r\n            if (iVar3 != 0) {\r\n                piVar4 = &var_48h;\r\n                iVar3 = iVar3 - (int32_t)piVar4;\r\n                do {\r\n                    cVar1 = *(char *)piVar4;\r\n                    piVar4 = (int32_t *)((int32_t)piVar4 + 1);\r\n                } while (cVar1 != '\\0');\r\n                piVar4 = (int32_t *)((int32_t)piVar4 - ((int32_t)&var_48h + 1));\r\n                iVar6 = iVar3 + 0xd;\r\n                if ((int32_t)piVar4 <= iVar6) {\r\n                    iVar6 = (iVar3 - (int32_t)piVar4) + 0xd;\r\n                }\r\n                cVar2 = *(char *)((int32_t)&var_48h + iVar6);\r\n            }\r\n            param_1[iVar7] = cVar2;\r\n            iVar7 = iVar7 + 1;\r\n            pcVar5 = param_1;\r\n            do {\r\n                cVar1 = *pcVar5;\r\n                pcVar5 = pcVar5 + 1;\r\n            } while (cVar1 != '\\0');\r\n        } while (iVar7 < (int32_t)(pcVar5 + -(int32_t)(param_1 + 1)));\r\n    }\r\n    fcn.0040163b((int32_t)param_1);\r\n    return;\r\n}\r\n\r\n```\r\n\r\nBefore each call to GetProcAddress the fcn.00401300 is called. Let's assume that fcn.00401300 is our decryption function for now.\r\n\r\n```c\r\nvoid __fastcall fcn.00401000(int32_t param_1)\r\n{\r\n    undefined4 uVar1;\r\n    code *pcVar2;\r\n    int32_t iVar3;\r\n    undefined4 *puVar4;\r\n    code *pcVar5;\r\n    code *pcVar6;\r\n    int32_t iVar7;\r\n    int32_t *piVar8;\r\n    int32_t iVar9;\r\n    int32_t iVar10;\r\n    int32_t unaff_EDI;\r\n    int32_t var_470h;\r\n    undefined4 var_46ch;\r\n    int32_t var_468h;\r\n    undefined4 var_464h;\r\n    undefined4 var_460h;\r\n    int32_t var_45ch;\r\n    int32_t var_458h;\r\n    int32_t var_454h;\r\n    int32_t var_448h;\r\n    undefined4 lpFilename;\r\n    int32_t var_4h;\r\n    \r\n    piVar8 = (int32_t *)(*(int32_t *)(param_1 + 0x3c) + param_1);\r\n    (*_GetModuleFileNameA)(0, &lpFilename, 0x400);\r\n    if (*piVar8 == 0x4550) {\r\n        _var_458h = ZEXT816(0);\r\n        fcn.004025b0(&var_448h, 0, 0x44);\r\n        fcn.00401300();\r\n        fcn.00401300();\r\n        pcVar5 = _LoadLibraryA;\r\n        uVar1 = (*_LoadLibraryA)(0x414894);\r\n        pcVar2 = (code *)(*_GetProcAddress)(uVar1, \"pe51g5Ceb35ffn\");\r\n        iVar3 = (*pcVar2)(&lpFilename, 0, 0, 0, 0, 4, 0, 0, &var_448h, &var_458h);\r\n        if (iVar3 != 0) {\r\n            fcn.00401300();\r\n            uVar1 = (*pcVar5)(0x414894);\r\n            pcVar2 = (code *)(*_GetProcAddress)(uVar1, 0x4148e8);\r\n            puVar4 = (undefined4 *)(*pcVar2)(0, 4, 0x1000, 4);\r\n            *puVar4 = 0x10007;\r\n            fcn.00401300();\r\n            uVar1 = (*pcVar5)(0x414894);\r\n            pcVar2 = (code *)(*_GetProcAddress)(uVar1, \"t5gG8e514pbag5kg\");\r\n            iVar3 = (*pcVar2)(var_454h, puVar4);\r\n            if (iVar3 != 0) {\r\n                fcn.00401300();\r\n                uVar1 = (*pcVar5)(0x414894);\r\n                pcVar5 = (code *)(*_GetProcAddress)(uVar1, \"E514Ceb35ffz5=bel\");\r\n                fcn.00401300();\r\n                uVar1 = (*_LoadLibraryA)(0x414894);\r\n                pcVar2 = (code *)(*_GetProcAddress)(uVar1, \"Je9g5Ceb35ffz5=bel\");\r\n                (*pcVar5)(var_458h, puVar4[0x29] + 8, &var_45ch, 4, 0);\r\n                fcn.00401300();\r\n                uVar1 = (*_LoadLibraryA)(0x414894);\r\n                pcVar5 = _GetProcAddress;\r\n                pcVar6 = (code *)(*_GetProcAddress)(uVar1, \"I9egh1/n//b3rk\");\r\n                iVar3 = (*pcVar6)(var_458h, piVar8[0xd], piVar8[0x14], 0x3000, 0x40);\r\n                (*pcVar2)(var_458h, iVar3, param_1, piVar8[0x15], 0);\r\n                iVar9 = 0;\r\n                if (*(int16_t *)((int32_t)piVar8 + 6) != 0) {\r\n                    iVar10 = 0;\r\n                    do {\r\n                        iVar7 = *(int32_t *)(param_1 + 0x3c) + iVar10;\r\n                        (*pcVar2)(var_458h, *(int32_t *)(iVar7 + 0x104 + param_1) + iVar3, \r\n                                  *(int32_t *)(iVar7 + 0x10c + param_1) + param_1, \r\n                                  *(undefined4 *)(iVar7 + 0x108 + param_1), 0);\r\n                        iVar9 = iVar9 + 1;\r\n                        iVar10 = iVar10 + 0x28;\r\n                        pcVar5 = _GetProcAddress;\r\n                    } while (iVar9 < (int32_t)(uint32_t)*(uint16_t *)((int32_t)piVar8 + 6));\r\n                }\r\n                (*pcVar2)(var_458h, puVar4[0x29] + 8, piVar8 + 0xd, 4, 0);\r\n                fcn.00401300();\r\n                pcVar2 = _LoadLibraryA;\r\n                uVar1 = (*_LoadLibraryA)(0x414894);\r\n                pcVar6 = (code *)(*pcVar5)(uVar1, \"F5gG8e514pbag5kg\");\r\n                fcn.00401300();\r\n                iVar9 = (*pcVar2)(0x414894);\r\n                pcVar5 = (code *)(*pcVar5)(iVar9, \"E5fh=5G8e514\");\r\n                puVar4[0x2c] = piVar8[10] + iVar3;\r\n                (*pcVar6)(var_454h, puVar4);\r\n                (*pcVar5)(var_454h);\r\n                fcn.0040163b(iVar9);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    fcn.0040163b(unaff_EDI);\r\n    return;\r\n    }\r\n```\r\n\r\n\r\nLooking at this iVar6 = iVar3 + 0xd; (0xd = 13) I have a sneaking suspicion that it is using ROT13 encoding.\r\nBut lets fire up x32dbg and put a BP 00401300, to further analyse it and verify this theory.\r\n\r\nOur encrypted strings\r\n\r\n```\r\n\r\n00000000  F5gG8e514pbag5kg\r\n00000014  .5ea5/QPY4//\r\n00000024  pe51g5Ceb35ffn\r\n00000034  I9egh1/n//b3rk\r\n00000044  E5fh=5G8e514\r\n00000054  Je9g5Ceb35ffz5=bel\r\n00000068  I9egh1/n//b3\r\n00000078  E514Ceb35ffz5=bel\r\n0000008C  t5gG8e514pbag5kg\r\n000000A0  .5ea5/QPY4//\r\n000000B0  F9m5b6E5fbhe35\r\n000000C0  s9a4E5fbhe35n\r\n000000D0  I9egh1/n//b3\r\n000000E0  yb3.E5fbhe35\r\n000000F0  yb14E5fbhe35\r\n\r\n```\r\n\r\nOur first encrypted strings\r\n\r\n```\r\n\r\n.5ea5/QPY4//\r\n\r\n```\r\n\r\nImma gonna need a quantum computer to crack this!\r\n\r\nIf we take the . and rotate 13 chars according to the lookup table (abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890./=) we end up on k. If we take the second char \"5\" and rotate 13, we get e, then e becomes r and so on and so forth.\r\n\r\n```\r\n\r\n.5ea5/QPY4// becomes kernel32.dll\r\n\r\n```\r\n\r\nAfter the API calls to get the RC4 enrypted .rsrc section are deobfuscated it will call the following API calls:\r\n\r\n```\r\nSizeofResource\r\nFindResourceA\r\nVirtualAlloc\r\nLockResource\r\nLoadResource\r\n\r\n```\r\n\r\nIf we set BP on LockResource, and let it hit (and return to user code), the address of the resource that it wans to read should be in the EAX register.\r\nIt will then call VirtualAlloc to assign a memory region for the resource.\r\n\r\nAfter the memory area is allocated, we come across sometthing that looks a lot like RC4 encryption (hint cmp eax, 100).\r\n\r\n```c\r\n    iVar12 = 0;\r\n    do {\r\n        *(char *)((int32_t)&var_108h + iVar12) = (char)iVar12;\r\n        iVar12 = iVar12 + 1;\r\n    } while (iVar12 < 0x100);\r\n    uVar9 = 0;\r\n    do {\r\n        cVar1 = *(char *)((int32_t)&var_108h + uVar9);\r\n        uVar14 = uVar14 + *(char *)(uVar9 % 0xf + 0xc + iVar10) + cVar1;\r\n        *(char *)((int32_t)&var_108h + uVar9) = *(char *)((int32_t)&var_108h + (uint32_t)uVar14);\r\n        uVar9 = uVar9 + 1;\r\n        *(char *)((int32_t)&var_108h + (uint32_t)uVar14) = cVar1;\r\n    } while ((int32_t)uVar9 < 0x100);\r\n    iVar10 = 0;\r\n    if (0 < iVar2) {\r\n        do {\r\n            var_8h._0_1_ = (uint8_t)var_8h + 1;\r\n            pcVar13 = (char *)((int32_t)&var_108h + (uint32_t)(uint8_t)var_8h);\r\n            cVar1 = *pcVar13;\r\n            var_8h._1_1_ = var_8h._1_1_ + cVar1;\r\n            *pcVar13 = *(char *)((int32_t)&var_108h + (uint32_t)var_8h._1_1_);\r\n            *(char *)((int32_t)&var_108h + (uint32_t)var_8h._1_1_) = cVar1;\r\n            *(uint8_t *)(iVar10 + iVar11) =\r\n                 *(uint8_t *)(iVar10 + iVar11) ^\r\n                 *(uint8_t *)((int32_t)&var_108h + (uint32_t)(uint8_t)(*pcVar13 + cVar1));\r\n            iVar10 = iVar10 + 1;\r\n        } while (iVar10 < iVar2);\r\n    }\r\n```\r\n\r\nEDI = size of encrypted data in hex \r\nedi=00015400 (87040 bytes)\r\n\r\nIf we look at this instruction in x32dbg we can see the RC4 key.\r\n\r\n00401592 | 0FB64438 0C              | movzx eax,byte ptr ds:[eax+edi+C]       | eax+edi*1+C:\"kkd5YdPM24VBXmi\"\r\n\r\nEAX = 0 (start of our rsrc section)\r\nEDI = .rsrc section at address 00416060 + C\r\n    \r\nWe can validate this by starting up HxD to check the key and the data after it\r\n    \r\n![HxD](resource_size.png)\r\n\r\nOur RC4 key is at offset C (12 bytes in)\r\n\r\nWith that knowledge, we should at least be able to make a Python script to unpack the first Stage of CruLoader.\r\n\r\nBut we still wanna know what it does, since we can see in the decompiled code that there are a few other encrypted strings which have not been decrypted yet.\r\n\r\nIf the let the decryption routine finish on the newly allocted memory region we can see a decrypted MZ binary. \r\n\r\n![decrypted_rsrc](decrypted_rsrc.png)\r\n\r\nAfter the .rsrc has been decrypted, it goes back to resoöving some more encrypted API calls. The calls are the following:\r\n```\r\n00000001  SetThreadContext\r\n00000025  CreateProcessA\r\n00000035  VirtualAllocEx\r\n00000045  ResumeThread\r\n00000055  WriteProcessMemory\r\n00000069  VirtualAlloc\r\n00000079  ReadProcessMemory\r\n0000008D  GetThreadContext\r\n```\r\n\r\nIt then calls this API to spawn a suspended copy of itself. This is starting to look like it will write the unpacked payload to a new child process.\r\n\r\n![Spawn_child](spawned_child.png)\r\n\r\n**Cruloaders second layer**\r\n\r\nSo. With that, let's look at the unpacked/decrypted payload we dumped out earlier to see what this second stage does.\r\n\r\nImports of our unpacked payload does not look that suspicous\r\n\r\nrabin2.exe -i unpacked_cruloader.exe\r\n\r\n```\r\n[Imports]\r\nNum  Vaddr       Bind      Type Name\r\n   1 0x0040f000    NONE    FUNC KERNEL32.dll_LoadLibraryA\r\n   2 0x0040f004    NONE    FUNC KERNEL32.dll_GetProcAddress\r\n   3 0x0040f008    NONE    FUNC KERNEL32.dll_VirtualFree\r\n   4 0x0040f00c    NONE    FUNC KERNEL32.dll_VirtualAlloc\r\n   5 0x0040f010    NONE    FUNC KERNEL32.dll_GetLastError\r\n   6 0x0040f014    NONE    FUNC KERNEL32.dll_GetModuleHandleW\r\n   7 0x0040f018    NONE    FUNC KERNEL32.dll_GetModuleFileNameA\r\n   8 0x0040f01c    NONE    FUNC KERNEL32.dll_lstrlenA\r\n   9 0x0040f020    NONE    FUNC KERNEL32.dll_MultiByteToWideChar\r\n  10 0x0040f024    NONE    FUNC KERNEL32.dll_CloseHandle\r\n  11 0x0040f028    NONE    FUNC KERNEL32.dll_WriteConsoleW\r\n  12 0x0040f02c    NONE    FUNC KERNEL32.dll_UnhandledExceptionFilter\r\n  13 0x0040f030    NONE    FUNC KERNEL32.dll_SetUnhandledExceptionFilter\r\n  14 0x0040f034    NONE    FUNC KERNEL32.dll_GetCurrentProcess\r\n  15 0x0040f038    NONE    FUNC KERNEL32.dll_TerminateProcess\r\n  16 0x0040f03c    NONE    FUNC KERNEL32.dll_IsProcessorFeaturePresent\r\n  17 0x0040f040    NONE    FUNC KERNEL32.dll_QueryPerformanceCounter\r\n  18 0x0040f044    NONE    FUNC KERNEL32.dll_GetCurrentProcessId\r\n  19 0x0040f048    NONE    FUNC KERNEL32.dll_GetCurrentThreadId\r\n  20 0x0040f04c    NONE    FUNC KERNEL32.dll_GetSystemTimeAsFileTime\r\n  21 0x0040f050    NONE    FUNC KERNEL32.dll_InitializeSListHead\r\n  22 0x0040f054    NONE    FUNC KERNEL32.dll_IsDebuggerPresent\r\n  23 0x0040f058    NONE    FUNC KERNEL32.dll_GetStartupInfoW\r\n  24 0x0040f05c    NONE    FUNC KERNEL32.dll_RtlUnwind\r\n  25 0x0040f060    NONE    FUNC KERNEL32.dll_SetLastError\r\n  26 0x0040f064    NONE    FUNC KERNEL32.dll_EnterCriticalSection\r\n  27 0x0040f068    NONE    FUNC KERNEL32.dll_LeaveCriticalSection\r\n  28 0x0040f06c    NONE    FUNC KERNEL32.dll_DeleteCriticalSection\r\n  29 0x0040f070    NONE    FUNC KERNEL32.dll_InitializeCriticalSectionAndSpinCount\r\n  30 0x0040f074    NONE    FUNC KERNEL32.dll_TlsAlloc\r\n  31 0x0040f078    NONE    FUNC KERNEL32.dll_TlsGetValue\r\n  32 0x0040f07c    NONE    FUNC KERNEL32.dll_TlsSetValue\r\n  33 0x0040f080    NONE    FUNC KERNEL32.dll_TlsFree\r\n  34 0x0040f084    NONE    FUNC KERNEL32.dll_FreeLibrary\r\n  35 0x0040f088    NONE    FUNC KERNEL32.dll_LoadLibraryExW\r\n  36 0x0040f08c    NONE    FUNC KERNEL32.dll_RaiseException\r\n  37 0x0040f090    NONE    FUNC KERNEL32.dll_GetStdHandle\r\n  38 0x0040f094    NONE    FUNC KERNEL32.dll_WriteFile\r\n  39 0x0040f098    NONE    FUNC KERNEL32.dll_GetModuleFileNameW\r\n  40 0x0040f09c    NONE    FUNC KERNEL32.dll_ExitProcess\r\n  41 0x0040f0a0    NONE    FUNC KERNEL32.dll_GetModuleHandleExW\r\n  42 0x0040f0a4    NONE    FUNC KERNEL32.dll_GetCommandLineA\r\n  43 0x0040f0a8    NONE    FUNC KERNEL32.dll_GetCommandLineW\r\n  44 0x0040f0ac    NONE    FUNC KERNEL32.dll_HeapFree\r\n  45 0x0040f0b0    NONE    FUNC KERNEL32.dll_HeapAlloc\r\n  46 0x0040f0b4    NONE    FUNC KERNEL32.dll_CompareStringW\r\n  47 0x0040f0b8    NONE    FUNC KERNEL32.dll_LCMapStringW\r\n  48 0x0040f0bc    NONE    FUNC KERNEL32.dll_GetFileType\r\n  49 0x0040f0c0    NONE    FUNC KERNEL32.dll_FindClose\r\n  50 0x0040f0c4    NONE    FUNC KERNEL32.dll_FindFirstFileExW\r\n  51 0x0040f0c8    NONE    FUNC KERNEL32.dll_FindNextFileW\r\n  52 0x0040f0cc    NONE    FUNC KERNEL32.dll_IsValidCodePage\r\n  53 0x0040f0d0    NONE    FUNC KERNEL32.dll_GetACP\r\n  54 0x0040f0d4    NONE    FUNC KERNEL32.dll_GetOEMCP\r\n  55 0x0040f0d8    NONE    FUNC KERNEL32.dll_GetCPInfo\r\n  56 0x0040f0dc    NONE    FUNC KERNEL32.dll_WideCharToMultiByte\r\n  57 0x0040f0e0    NONE    FUNC KERNEL32.dll_GetEnvironmentStringsW\r\n  58 0x0040f0e4    NONE    FUNC KERNEL32.dll_FreeEnvironmentStringsW\r\n  59 0x0040f0e8    NONE    FUNC KERNEL32.dll_SetEnvironmentVariableW\r\n  60 0x0040f0ec    NONE    FUNC KERNEL32.dll_SetStdHandle\r\n  61 0x0040f0f0    NONE    FUNC KERNEL32.dll_GetStringTypeW\r\n  62 0x0040f0f4    NONE    FUNC KERNEL32.dll_GetProcessHeap\r\n  63 0x0040f0f8    NONE    FUNC KERNEL32.dll_FlushFileBuffers\r\n  64 0x0040f0fc    NONE    FUNC KERNEL32.dll_GetConsoleOutputCP\r\n  65 0x0040f100    NONE    FUNC KERNEL32.dll_GetConsoleMode\r\n  66 0x0040f104    NONE    FUNC KERNEL32.dll_SetFilePointerEx\r\n  67 0x0040f108    NONE    FUNC KERNEL32.dll_HeapSize\r\n  68 0x0040f10c    NONE    FUNC KERNEL32.dll_HeapReAlloc\r\n  69 0x0040f110    NONE    FUNC KERNEL32.dll_CreateFileW\r\n  70 0x0040f114    NONE    FUNC KERNEL32.dll_DecodePointer\r\n```\r\n\r\nWhat about the sections? Nope\r\n\r\nrabin2.exe -S unpacked_cruloader.exe\r\n```\r\n[Sections]\r\nNm Paddr       Size Vaddr      Memsz Perms Name\r\n00 0x00000400 55808 0x00401000 57344 -r-x .text\r\n01 0x0000de00 23552 0x0040f000 24576 -r-- .rdata\r\n02 0x00013a00  2560 0x00415000  8192 -rw- .data\r\n03 0x00014400  4096 0x00417000  4096 -r-- .reloc\r\n```\r\n\r\nDiE is not showing high entropy for any of the sections.\r\n\r\nLooking at the strings in the binary, shows something intersting though, a string \"cruloader\" and a dll for which there are no API imports. Does it perhaps contain network functionality since there is a reference to wininet.dll? But where is the hostname/URL?\r\n```\r\n1062 0x00012a1c 0x00413c1c  12  13 (.rdata) ascii kernel32.dll\r\n1063 0x00012a2c 0x00413c2c   9  10 (.rdata) ascii ntdll.dll\r\n1064 0x00012a38 0x00413c38  11  12 (.rdata) ascii wininet.dll\r\n```\r\n\r\nTaking a quick look at it Cutter shows something suspicous. My favorite party trick, is to search for all XOR instructions.\r\nOne of them sticks out a bit (there a more, but we will get to those later)\r\n```\r\nxor ecx, 0xedb88320\r\nxor edx, 0xedb88320\r\n```\r\nBefore two of the calls to GetProcAddress, this function is called. I have a sneaking suspicion that the constant \"0xedb88320\" is used for something important. \r\nGoogling on the constant \"0xedb88320\" indicates that it is used for CRC32 hashing.\r\n\r\nThere are 2 xrefs to this function at 0x00401660. We will look at the second use of it furher into the analysis.\r\n\r\n```c\r\nuint32_t __cdecl fcn.00401660(int32_t arg_8h)\r\n{\r\n    uint8_t uVar1;\r\n    uint32_t uVar2;\r\n    uint8_t *in_EDX;\r\n    uint32_t uVar3;\r\n    uint32_t uVar4;\r\n    uint8_t *puVar5;\r\n    \r\n    if (*(int32_t *)0x41628c == 0) {\r\n        uVar4 = 0;\r\n        do {\r\n            uVar3 = uVar4 >> 1 ^ 0xedb88320;\r\n            if ((uVar4 & 1) == 0) {\r\n                uVar3 = uVar4 >> 1;\r\n            }\r\n            uVar2 = uVar3 >> 1 ^ 0xedb88320;\r\n            if ((uVar3 & 1) == 0) {\r\n                uVar2 = uVar3 >> 1;\r\n            }\r\n            uVar3 = uVar2 >> 1 ^ 0xedb88320;\r\n            if ((uVar2 & 1) == 0) {\r\n                uVar3 = uVar2 >> 1;\r\n            }\r\n            uVar2 = uVar3 >> 1 ^ 0xedb88320;\r\n            if ((uVar3 & 1) == 0) {\r\n                uVar2 = uVar3 >> 1;\r\n            }\r\n            uVar3 = uVar2 >> 1 ^ 0xedb88320;\r\n            if ((uVar2 & 1) == 0) {\r\n                uVar3 = uVar2 >> 1;\r\n            }\r\n            uVar2 = uVar3 >> 1 ^ 0xedb88320;\r\n            if ((uVar3 & 1) == 0) {\r\n                uVar2 = uVar3 >> 1;\r\n            }\r\n            uVar3 = uVar2 >> 1 ^ 0xedb88320;\r\n            if ((uVar2 & 1) == 0) {\r\n                uVar3 = uVar2 >> 1;\r\n            }\r\n            uVar2 = uVar3 >> 1 ^ 0xedb88320;\r\n            if ((uVar3 & 1) == 0) {\r\n                uVar2 = uVar3 >> 1;\r\n            }\r\n            *(uint32_t *)(uVar4 * 4 + 0x416690) = uVar2;\r\n            uVar4 = uVar4 + 1;\r\n        } while ((int32_t)uVar4 < 0x100);\r\n        *(int32_t *)0x41628c = 1;\r\n    }\r\n    uVar4 = 0xffffffff;\r\n    puVar5 = in_EDX + arg_8h;\r\n    if (in_EDX < puVar5) {\r\n        do {\r\n            uVar1 = *in_EDX;\r\n            in_EDX = in_EDX + 1;\r\n            uVar4 = uVar4 >> 8 ^ *(uint32_t *)((uVar4 & 0xff ^ (uint32_t)uVar1) * 4 + 0x416690);\r\n        } while (in_EDX < puVar5);\r\n    }\r\n    return ~uVar4;\r\n}\r\n```\r\n\r\nLet's validate this somehow by firing up x32dbg and correlate this with the tool rahash2.\r\n```\r\nx32dbg hash found:\r\n\r\ndword ptr [ebp-C]=[0018FAE4]=8436F795\r\n\r\nrahash2.exe -a crc32 -s \"IsDebuggerPresent\"\r\n0x00000000-0x00000010 crc32: 8436f795\r\n\r\nx32dbg hash found:\r\n\r\ndword ptr [ebp-C]=[0018F884]=C1F3B876\r\n\r\nrahash2.exe -a crc32 -s \"CreateToolhelp32Snapshot\"\r\n0x00000000-0x00000017 crc32: c1f3b876\r\n\r\nx32dbg hash found:\r\ndword ptr [ebp-C]=[0018F884]=8197004C\r\n\r\nrahash2.exe -a crc32 -s \"Process32FirstW\"\r\n0x00000000-0x0000000e crc32: 8197004c\r\n\r\nx32dbg hash found:\r\ndword ptr [ebp-C]=[0018F884]=BC6B67BF\r\n\r\nrahash2.exe -a crc32 -s \"Process32NextW\"\r\n0x00000000-0x0000000d crc32: bc6b67bf\r\n```\r\nWhelps! What will it do with this information? Find a process to inject into? Be mean to us analysts and mess with us if a \"forbidden\" process is found?\r\n\r\nWTH? Sure enough, the process exited after it had gone through all the running processes. That's just evil. So how do we find out which process it is looking for?\r\nIt looks like it uses the CRC32 function we saw before against any running processes.\r\n\r\nKilling ProcessHacker seems to do the trick. It also seems to check for Wireshark and possibly some other running process.\r\nNow that the bp for CreateProcessInternalW gets hit and a suspended svchost.exe process gets created:\r\n\r\ndword ptr [ebp+C]=[0018F9F4 &\"C:\\\\Windows\\\\System32\\\\svchost.exe\"]=0018FAA0 \"C:\\\\Windows\\\\System32\\\\svchost.exe\"\r\n\r\nAfter the BP is hit, we can start up ProcessHacker once again.\r\n\r\nWhy did it inject into svchost.exe? There was no strings visible with that in the second stage binary.\r\nThe reason is one of the string in the second stage is obfuscated with this:\r\n```\r\nrol dl,4\r\nxor dl,A2                               |\r\n```\r\nThe string (hex)\r\n```\r\n\r\n1E 89 EF 5F BC CC 6C DC 5D 1D EF 1F BD 1D 6D 7C FC 19 09 EF 1D 4D 1C AC DC 1D 6D C8 7C AD 7C 00 86 12 40\r\n\r\n```\r\nBecomes\r\nC:\\Windows\\System32\\svchost.exe\r\nThis explains why it got injected into \"svchost.exe\"\r\n\r\nIt creates a RemoteThread in the suspended svchost.exe process at address 00101DC0 in my case, where it will continue execution in the spawned child process\r\n\r\nIn the spawned svchost it once again uses CRC32 hashing to resolve API calls from wininet.dll\r\n\r\n```\r\nInternetOpenA\r\nInternetOpenUrlA\r\nInternetReadFile\r\nInternetCloseHandle\r\nHttpQueryInfoA\r\n\r\n```\r\n\r\nHmmm. API calls to internet connectivity, but we don't see any URL/hostname in the binary. Where is it hiding?\r\n\r\nIf we set a BP on InternetOpenUrlA we can see that URL \"https://pastebin.com/raw/mLem9DGk\"\r\n\r\nThe URL is obfuscated with:\r\n```\r\nrol dl,4  \r\nxor dl,C5\r\n```\r\n\r\nWe can verify this by dragging the unpacked CruLoader binary into Cyberchef and use this recipe:\r\n```\r\nEncoded URL in hex: DA 1B 1B 5B 6B FF AE AE 5B 4A 6B 1B 0A 7A CA BA BE 6A AA 8A AE 7B 4A 2B AE 8A 98 0A 8A CF 18 28 EA\r\n\r\nRotate_left(4,false)\r\nXOR({'option':'Hex','string':'C5'},'Standard',false)\r\nExtract_URLs(false)\r\n```\r\n\r\nOn that page is the following data\r\nhttps://i.ibb.co/KsfqHym/PNG-02-Copy.png\r\n\r\nIf we download that file, it is a .png file\r\n\r\nLet's be sneaky and grab the .png file, then fire up Inetsim and let CruLoader grab first the link https://i.ibb.co/KsfqHym/PNG-02-Copy.png from https://pastebin.com/raw/mLem9DGk\", which is our InetSim service. Hopefully makes it a bit easier to see if anything \"fun\" happens with that .png file.\r\n\r\nFor this to work, since it's calling /raw in pastebin we may have to remove all html tags from Inetsims sample.html and also change the URL to \r\nhttp://i.ibb.co/KsfqHym/PNG-02-Copy.png. Reason being, is that InetSim is kinda bad at faking SSL certs. :)\r\n\r\nThe file PNG-02-Copy.png is copied into the InetSim folder, in my case:\r\ncp PNG-02-Copy.png /var/lib/inetsim/http/fakefiles/sample.png\r\n\r\nI was also a bit cheeky and changed the pastebin URL in the sample to\r\nhttp://pastebin.com/index.html \r\n\r\n![Sneaky sneaky](sneaky_change_url.png)\r\n\r\nThe next string output.jpg is encrypted with\r\n```\r\nrol cl,4  \r\nxor cl,1F\r\n```\r\nWhich is the filename, of the payload (in the PNG file) that will be written to disk\r\n\r\nOnce the .png file is downloaded it will once again call the CRC32 API hashing function and resolve:\r\n\r\n```\r\nGetTempPathW\r\nCreateDirectoryW\r\nCreateFileW\r\nWriteFile\r\n```\r\n\r\nit will use these to create a directory in %TEMP%\\\\cruloader\" with the file \"output.jpg\". This is our downloaded .png file.\r\n\r\nTHe string \"redaolurc\" is encrypted with:\r\n```\r\nrol cl,4\r\nxor cl,9A\r\n```\r\n\r\nAfter that strings is deobfuscated it checks for the string \"IHDR\" in the memory region allocated for the downloaded .png file and the string \"redaolurc\"\r\n\r\nIf we look at the data after the string \"redaolurc\" it seems to indicate that it's been XORED with 0x61 (the char \"a\")\r\n\r\n![redaolurc](redaolurc_EOF.png)\r\n\r\nDe-XORing the .png file with 0x61 reveals that it's a Windows binary. \r\nWe can trim the file by removing everything before the MZ header and then resize the file with PE-Bear.\r\n\r\nContinuing exectution, it spawns a new svchost.exe process in which it injects the decrypted .png file.\r\n\r\nThe final payload contains an interesting string in form of PDB path, which we could build a YARA rule for.\r\n\"C\":\\Users\\User\\source\\repos\\Cruloader_Payload\\Release\\Cruloader_Payload.pdb\"\r\n\r\nFunctionality for the final payload is to display a Messagebox\r\n![Final_payload](final_payload_function.png)\r\n\r\n**To automate parts of the extraction of the first packed layer and download of the .png payload I have created the following Python script:**\r\n(Note that I am quite the beginner at Python coding, so the code may not be the best)\r\n\r\n[CruLoader_Unpacker_Downloader](cruloader_unpacker_downloader.py)\r\n\r\n","note":"Don't delete this file! It's used internally to help with page regeneration."}